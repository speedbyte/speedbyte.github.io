---
layout: post
---



License key

bin/vtdStart.sh:export VI_LIC_DEVICE="wlx00e061486ada"

===== CARLA =====



The simulator can be started by running CarlaUE4.sh on Linux, or CarlaUE4.exe on Windows. Unlike previous versions, now the simulator automatically starts in "server mode". That is, you can already start connecting your Python scripts to control the actors in the simulation.

Building boost with clang support.
0.8-2 Carla is based on clang 3.9 and Boost 1.64.0
0.8.4 Carla is clang 5.0 and Boost 1.67.0

Also protobuf is needed, googletest, ZLIB, LLVM

Same compiler version and C++ run time library. clang 5.0

Trying 4.19.2 and 0.9.0 and it works. First build 4.19.2. Start the Unreal Engine once - ./Engine/Binaries/Linux/UE4Editor

Takes a long time ... be patient

Content is important. Its around 10GB.

make package

The release package contains the following

    The CARLA simulator.
    The "carla" Python API module.
    A few Python scripts with usage examples.

./CarlaUE4.sh /Game/Carla/Maps/Town02 -carla-port=N

SCRIPT_DIR/Util/ContentVersions.txt

https://drive.google.com/file/d/1FtC00CrDb7Kz5StBAwb6vqOGbzZtpROx/ - 0.9.0

make package creates the distribution. After that the source can be removed. However, Python Client is not created.

/CarlaUE4.sh -benchmark -fps=5

-carla-settings="./CarlaUE4/Config/CarlaSettings.ini" 

pip install -r PythonClient/requirements.txt

$ ./client_example.py --autopilot

$ ./client_example.py --autopilot --images-to-disk

$ ./CarlaUE4.sh -carla-server

./CarlaUE4.sh /Game/Carla/Maps/Town01 -windowed -world-port=2000  -benchmark -fps=10


If running from Unreal, Unreal creates a copy of the project in the CARLA folder with the name CARLA UE4 .19

World Port - 2000
[client] RequestNewEpisode
[server] SceneDescription
[client] EpisodeStart
[server] EpisodeReady

Measurement Port - 2001
ONly server writes. First measurements and then a bunch of images.
[server] Measurements
[server] raw images
...repeat...


Measurement - 


./CarlaUE4.sh -benchmark -fps=5

./CarlaUE4.sh /Game/Carla/Maps/Town01 -windowed -ResX=320 -ResY=240

./CarlaUE4.sh /Game/Carla/Maps/Town01 -windowed -ResX=320 -ResY=240 -world-port=2000 -carla-server -bencmark -fps=1  -carla-settings='/local/tmp/CarlaSettings.ini'

Since version 0.8.0 the positions of the sensors are specified in meters instead of centimeters. Always relative to the vehicle.


easy_install2 --user --no-deps PythonAPI/dist/carla-0.9.0-py2.7-linux-x86_64.egg
easy_install3 --user --no-deps PythonAPI/dist/carla-0.9.0-py3.5-linux-x86_64.egg



All the actors can be created and destroyed at any point during the simulation, and all of them can be controlled or moved around. In this release only vehicles and cameras are available but in coming releases we’ll add pedestrians and traffic lights as well.



    Actor: Actor is anything that plays a role in the simulation and can be moved around, examples of actors are vehicles, pedestrians, and sensors.
    Blueprint: Before spawning an actor you need to specify its attributes, and that’s what blueprints are for. We provide a blueprint library with the definitions of all the actors available for you to choose.
    World: The world represents the currently loaded map and contains the functions for converting a blueprint into a living actor moving around in the simulation.



Hi @wobistdu,

You are using the 0.8.x API with the 0.9.0 simulator, they're no longer compatible. The 0.9.0 is a work-in-progress showing the new API we are implementing.

    The new client (0.9.x) is located in PythonAPI folder.
    The old client (0.8.x) is located in PythonClient folder.

Sorry for the confusion, we are in middle of the transition between the two APIs and documentation is still a bit messy.


===== PCAN =====


cp receivetest transmitest bitratetest filtertest pcanfdtst pcan-settings /usr/local/bin



===== VIRES =====




note: each IG inherently calculates color and depth image; the concurrent visualization of each is the main feature of this setup)
The flipMirror uniform configures if the image is flipped ("1 0"), mirrored ("0 1") or both ("1 1").

if configureDisplay.sh is empty then Automatic Configuration is switched off
ignoreSEtProjectionMessage should be st to 0 in order to handle the projection from SCP message.
offset HPR and XYZ either from SymmetricProjection in configureDisplay.sh or through 


SimServer - IG Process with mask -> cfgA.xml ( calls cfgDisplay.xml ; some settings for IG like material, light database etc. ) -> cfgDisplayA.xml ( rendering surface of the image etc ).
Start script -> Camera cam1 with mask. The mask bit connects the simserver settings and the start script setting. Also cam1 is defined in AutoCfgDisplay.xml / cfgDisplayA.xml to connect between the IGsetting and simserver setting

startScriptSimulation <-> simServer.xml <-> AutoCfgDisplay.xml should be synchronous with each other.




Traffic simulation node in VIRES controls dynamics of vehicles. It is also responsible for animation of traffic and scenarios.
Traffic means vehicles, pedesterians, objects. Scenarios means actions at run time.

However, if the vehicle is assigned as external in the scenario editor then its dynamics is controlled
over a module manager plugin. Two categories of vehicles are present - Base vehicle dynamics and complex vehicle dynamics.
Apart from the dynamics of other vehicles, own vehicle can also be controlled via module manager plugin.
Its important to see that vehicle dynamics does not mean vehicle control. Vehicle dynamics is for exanple, how
rigid is the tyre, the coeffiecnts of springs on the suspension etc.

The user might read directly from the task control or it might also read from a module manager plugin. The module manager plug in a subset
of the entire task control RDB. 

At each given point of time, each instance of the IG may render exactly one image from a given eyepoint. The rendered image is displayed on a monitor. 
Complex image renderings and image transfers will usually interfere with the real-time requirements. In this case, the IG will be operated in frame-synchronous mode, i.e. it delivers images upon discrete requests and is tightly linked to the TaskControl. This option is Sync using extern.

Upon a re-start, the following actions will be performed: ? termination of running v-IG ? execution of script Data/Scenarios/Common/Scripts/configureIG.sh ? execution of script Data/Scenarios/Common/Scripts/configureDisplay.sh ? start of v-IG

The window for graphical output is defined in the file AutoCfgDisplay.xml. If in automatic configuration mode, this file will be generated by the script configureDisplay.sh which is invoked by the TaskControl. 

The file AutoCfgDatabase.xml is created via the script configureIG.sh. This script will be invoked by the TaskControl. Only if the automatic configuration is disabled in the TaskControl's configuration file, the script will not be called

If players are external, then the control is fed from the external modules via module manager.
so, you make your control as a module manager plug in and then attach that library into VIRES. A 
plug in can be like, a text everytime two players come very close to each other.

TC sends the Cmaera settings to IG

Sensor plugins are used for the processing (e.g. filtering) of the simulated environment. The results may be used as inputs for the interpretation in algorithms of active safety and assistance systems. One key feature of the sensor models is the filtering of all available data into a reduced stream of relevant data within certain spatial constraints (see following figure) which can be forwarded to other components.

The ModuleManager runs at a user-configurable speed (default: 100Hz). The update routines of the module plug-ins are called in each frame.

The RDB port (RDBraw) and communication type (TCP) have to be defined so that the manager knows how to connect to the TC. In case of a UDP connection, the manager will automatically open a feedback channel on a separate, pre-configured port number.

Alternating buffer. which means double buffer would be created.
One buffer is processed by the user, while other is being filled.


By setting ignoreShmFlags to "1", a new image is written each frame to the shared memory without waiting for any consumers. Otherwise (i.e. if set to zero), a new image will only be written to a shared memory buffer if the buffer is not locked (i.e. the buffer flag RDB_SHM_BUFFER_FLAG_LOCK is not set and the TC bit RDB_SHM_BUFFER_FLAG_TC is cleared). Note that the shared memory may be double buffered, i.e. always check the buffer flags first so that no data is read from locked buffers.

Paramter Browser - saves configuration data for task control

Module Manager is in the public interface

SimServer - 32512
Param Server - 48179
Task Control - 48190
Module Manager - 48185



RDBtrigger sends an image at requestImage = true. It sends GroundTruth data for the same frame.


the attributes dx, dy, dz, dhDeg, dpDeg, drDeg may be used in connection with the type relative only. Using these offsets, you may set the reference system's origin anywhere relative to the sensor's carrier. So, the attributes dx... does not make any sense in any origin other than relative.

In packages containing data of type OBJECT_STATE_t (typically positions of vehicles etc.), you will find the position of an object's reference point (in member pos), the object's size and the position of its center of geometry (both in member geo with dimX = length, dimY = width and dimZ = height). For a vehicle, these elements are shown in the following image (note that y-offset and z-offset are both zero):

Position and orientation of the object in meters and degrees with the origin being the sensor origin.
x,y,z,h,p,r plus the original dimension from PerfectSensor. 
Dimension of the object ( from camera coordinate system ) in pixels. The dimension of the objects in meters is always the original dimension.
CameraSensor


Object_cfg. object_state
Sensor_state, sensor_object


ShowOwner and ShowCone doesnt affect each other. The car configured to have the sensor will supply the sensor data. 

Sending SCP  as ExampleConsole works. The word ExampleConsole is just for the Display purpose i.e whre the message actually came from.

In Sync via RDB -- 
RDB Triggers TaskControl and TaskControl triggers IG. 

In Sync via extern -
the IG triggers Taskcontrol every ? ms. Hence if sync is set to extern and nevertheless RDB messages are sent to the TC, then a deallock may occur.

Triggering

Internal triggering:
	Internal triggering means that the simulation loop is triggered from within the taskControl
	<Sync  source="intern" 
       realTime="true" 
       frameTimeMs="40"/>

realTime=true means the time is taken from the clock ( unlike debugger, where the time is taken from the debugger )
realTime=true also means, that the 40ms width means 40ms. If realTime=false, then the 40ms step is not given heed to.
It means that the simulation will run the next frame, and not wait for 40ms to finish.

External triggering
	External triggering means that the simulation loop is NOT triggered from within the taskControl. In this case, the triggering is done by IG. IG triggers the Task control.
	
	Method 1 The trigger signal is linked to the trigger signal of the image generator.
	<Sync  source="extern" 
       realTime="true"/>
	
	Data/Setups/Current/Config/ImageGenerator/IGbase.xml
	30Hz
	<TAKATA ....
	    constantDeltaTime="0.0333333333" 
	    useConstantDeltaTime="1" 
	... />


	
	Method 2 The trigger signal is send via RDB. Send RDB message of type RDB_PKG_ID_TRIGGER. The trigger message does not necessarily have to be surrounded by START and END of FRAME messages.

	<Sync  source="RDB" />


	typedef struct
    {
    float   deltaT; 
    int32_t frameNo;   
    int32_t spare;   
    } RDB_TRIGGER_t;

    Method 3 - SCP

    <Sync  source="SCP" />
    <SimCtrl><Sync dt="0.03333333"/></SimCtrl>
    The delta time of the next simulation step (dt) in the example is given for a 30Hz frame rate and may be any arbitrary number greater than 1ms.

    Method 4: 
    Module Manager through libModuleTrigger.so
	<RDB>
	    <Port name="RDBraw" number="48190" type="TCP" />
	</RDB>

	<DynamicsPlugin name="viTrigger">
	    <Load     lib="libModuleTrigger.so" path=""/>
	    <Player   default="false" />
	    <Config   verbose="false" />
	    <Config   entity="timer" baseDelta="0.002" />  <!-- basic delta time is 2ms -->
	    <Config   entity="timer" offset="0.0" delta="0.016" featureMask="0x0003"/>  <!-- IG -->
	    <Config   entity="timer" offset="0.0" delta="0.010" featureMask="0x0001"/>
	    <Config   entity="timer" offset="0.0" delta="0.050" featureMask="0x0001"/>
	    <Debug    enable="false" />
	</DynamicsPlugin>

    
	Method 5 - Dynamics
	<Dynamics  syncMode="frame"/> - the next simulation frame will only be triggered after the input from the vehicle dynamics has arrived.
	OR
	<Dynamics  syncMode="free"/>


    Method 6 - 3rd Party
	
	<Query entity="RDB"> <Sync source="myComp123" /> </Query>

	typedef struct
	{
	    uint32_t mask;     
	    uint32_t spare[3];
	} RDB_SYNC_t; 

	Unregister
	<Query entity="RDB"> <Sync source="myComp123" delete="true"/> </Query>     

	Method 7 - SHM
	The SHM synchronization of standard VTD components is currently only performed by the Image Generator.


Sequence - 
 - vtdStart.sh
 - loads .vpj file
 - prepares SimServer ( TCPServer ) and binds on 32512 on which the simServer communicates with other internal modules
 - prepares SCPServer and binds on 48179. The SCP client sends messages here to configure the project.
 - Depending on the configuration parameters in the SCP file that is sent to the SCP Server, RDB Trigger port ( default 48190 ) and RDB Out ports ( 48185 )are bound.

The .vpj files have different groups -

1. Display group
2. Sensor group ( here if the sensor group is selected, then selected=true, otherwise selected=false )


All the parameters in the group can also be set via SCP messages. The SCP XML messages are of the type

1. ViewGroup 
2. SceneGroup
3. CameraGroup
4. DisplayGroup <Display ... /Display>
5. SensorGroup  <Sensor .... /Sensor>


Data from VTD

VTD provides an extensive set of binary data for each simulation step. The overall amount of data that is available on RDB is listed in the respective documentation. Some of the more important / frequent contents are given in the following list:

Player Data (Vehicles, Pedestrians)

    position, orientation (heading, pitch, roll) and size (bounding-box)
    category of the player (vehicle, pedestrian)

Details of Vehicles

    size, mass, axle distance
    information about drivetrain (speed, torque, gear...)
    information about driver-vehicle-interface (e.g. pedals, steering wheel)
    detailed information about wheels (steering angle, radius, forces etc.)
    brake pressure, spring compression (per wheel)
    status of vehicle lights

    Note: depending on the vehicle dynamics model, not all values may be available or may be interpreted. For the standard VTD vehicle dynamics implementations (single-track model / physics-engine model), the following inputs are supported:
        steering target / acceleration target / gear (D/N)
        throttle / brake / steering wheel / gear (D/N)

Details of current road sections

    drive lane information (width, id, ...)
    road marks (type, color, ...)
    traffic signs and traffic lights (including current and future states)

Images of the Image Generator

    height, width
    image data (visual range, depth information, infrared, ...)
    information about the camera which is used for generating the image (make sure you configure the TaskControl to the latest IG protocol version for this feature, i.e. "precision10" or higher)

Sensor Data

Perfect sensors may be positioned at arbitrary locations of vehicles. These may be used to simulate real sensors. Sensor output data is provided on dedicated connections of each sensor. The protocol also follows the RDB definition.

    position of the sensor
    distance to detected objects (with global object reference)

Common Data

    time-of-day
    sky state
    weather conditions (fog, rain, snow)
    visibility
    road conditions (dry, wet)

Data into VTD

As stated above you may also send RDB-formatted data into the simulation. In the usual case (i.e. Standard VTD configuration), only the TaskControl will be able to accept these data. The following RDB data types are the ones which the TaskControl understands (excerpt from receiver source code):

        case RDB_PKG_ID_LIGHT_SOURCE:
        case RDB_PKG_ID_DRIVER_CTRL:
        case RDB_PKG_ID_SYNC:
        case RDB_PKG_ID_OBJECT_STATE:
        case RDB_PKG_ID_ENGINE:
        case RDB_PKG_ID_DRIVETRAIN:
        case RDB_PKG_ID_WHEEL:
        case RDB_PKG_ID_VEHICLE_SYSTEMS:
        case RDB_PKG_ID_VEHICLE_SETUP:
        case RDB_PKG_ID_TRIGGER:
        case RDB_PKG_ID_TRAFFIC_LIGHT:
        case RDB_PKG_ID_END_OF_FRAME:
        case RDB_PKG_ID_START_OF_FRAME:

The following messages are understood but may not be completely implemented. So do NOT send them without being requested or authorized to do so:

        case RDB_PKG_ID_SENSOR_STATE:
        case RDB_PKG_ID_SENSOR_OBJECT:
        case RDB_PKG_ID_OBJECT_CFG:
        case RDB_PKG_ID_PED_ANIMATION:
        case RDB_PKG_ID_CUSTOM_SCORING:
        case RDB_PKG_ID_CUSTOM_AUDI_FORUM:
        case RDB_PKG_ID_SCP:


/********************************************************
VTD Connector
 * Enables communication with simple (custom) messages. *
********************************************************
*
*
* (Proxy-)Message containing:
* ---------------------------
* uint16 - protocol
* uint16 - package/message ID
* uint32 spare[6] - spares
* uint32 - data size (size of message data following this entry) in bytes
*
*
* Message data must contain:
* ---------------------------
* message type
* sender information
* actual data to be processed (traffic signs, road information, other vehicles, etc.)
*
*/

/**

 prjParameter in .vpj file is picked up from Projects/Current/Config/<filename>
 <Testcase author="" created="06.06.2011/18:49:16" modified="25.01.2018/14:57:27" name="Unnamed"
 prjParameter="RDBtrigger" scenario="Current/Scenarios/two.xml">
 "<SimCtrl><UnloadSensors /><LoadScenario filename="/local/git/PriorityGraphSensors/VIRES/VTD.2
 .0/Data/Projects/Current/Scenarios/two.xml" /><Start mode="operation" /></SimCtrl>"
 .
 .
 .
 .
 </Testcase>

 48195 - RDBout - MM
 48190 - RDBraw - MM
 rdbsniffer -c tcp -p port

 If you do not click the Apply button, then you can change the paramters using the parameter browser. In case you
 have already clicked the Apply button, then you can go back to the config mode, by pressing the Configure button.
 Ofcourse you have to stop a running simualtion first. Thereafter all processes like IGCtr, ModuleManager and Traffic
 will stop, but Task Control,  Parameter Server and the GUI Client will be continue.

 The video is started by clicking on the video record button on the left and is stopped by clicking on the video stop
 buton on the right. The conversion processes are described in Setups/Common/Scripts/vrecConvert.sh.
 Instructions from operating from command line only, AdvancedSetup, autoStart, autoConfig.
 GUI-less and IG-less Operation (auto-started / auto-configured simulation)
 purpose is to run VTD in a headless test automation environment without any rendering (i.e. only RDB data is of
 interest)

 One needs to add the post processing step in the IGBase.xml in order to write the images to the shared memory. The
 IG post processing pipeline allows rendering of a scene with subsequent modification and combination of generated
 images. Sample use cases of the pipeline include corrective image warping for projection on uneven surfaces, tone
 mapping of HDR images and various visual effects including depth of view.
 Post processing is implemented by the IG Component PostProcessing.
  - PostProcessing with a name.
  - PostProcessingPipelineConfigurator with a name.
  - single pipeline child with one or more steps as children.

 Rendering the scene into a texture and then display it.

 IGBase.xml <ShmLayoutImage key="0x0811b" freeFlag="0x00000000" releaseFlag="0x00000002"/>
 ProjectIGBase.xml

 autoStart, autoConfig. autoStart invokes the scpGenerator with the parameter tcpAutoStart.scp

 ------ shared memory identifiers ------
 #define RDB_SHM_BUFFER_FLAG_NONE                    0x00000000      /**< no bits set, buffer may be overwritten
 #define RDB_SHM_BUFFER_FLAG_LOCK                    0x00000001      /**< buffer is locked by producer
 #define RDB_SHM_BUFFER_FLAG_TC                      0x00000002      /**< buffer is to be processed by TC
 #define RDB_SHM_BUFFER_FLAG_IG                      0x00000004      /**< buffer is to be processed by IG

 Setups -> AutoCfgDatabase.xml  -> here is your scene in Projects/Current/Databases/*.ive file
                                -> here is your occlusion in Projects/Current/Databases/*.occl file
                                all of them are soft link to Distros/Databases

 The primary source and receiver of RDB is the Task Control.
 Module Manager sends and receives data to and from RDB. The data is then forwarded to the plugins. The plugins
 refactors/exterds the data with additional information and then sends it again on the RDB. The data can only be sent
 by plugins and not received directly.
 RDB_MSG_HDR_t        headerSize  = sizeof( RDB_MSG_HDR_t )
                      dataSize    = sum of all following "headerSize" and "dataSize" information, i.e.
                                     5 * sizeof( RDB_MSG_ENTRY_HDR_t ) +
                                     3 * sizeof( TypeA ) +
                                     1 * sizeof( TypeB ) +
                                     2 * sizeof( TypeC )
 RDB_MSG_ENTRY_HDR_t  pkgId       = RDB_PKG_ID_START_OF_FRAME
                      headerSize  = sizeof( RDB_MSG_ENTRY_HDR_t )
                      dataSize    = 0
                      elementSize = 0
 RDB_MSG_ENTRY_HDR_t  pkgId       = TypeA
                      headerSize  = sizeof( RDB_MSG_ENTRY_HDR_t )
                      dataSize    = 3 * sizeof( TypeA )
                      elementSize = sizeof( TypeA )
     entryOfTypeA
     entryOfTypeA
     entryOfTypeA
 RDB_MSG_ENTRY_HDR_t  pkgId       = TypeB
                      headerSize  = sizeof( RDB_MSG_ENTRY_HDR_t )
                      dataSize    = 1 * sizeof( TypeB )
                      elementSize = sizeof( TypeB )
     entryOfTypeB
 RDB_MSG_ENTRY_HDR_t  pkgId = TypeC
                      headerSize  = sizeof( RDB_MSG_ENTRY_HDR_t )
                      dataSize    = 2 * sizeof( TypeC )
                      elementSize = sizeof( TypeC )
     entryOfTypeC
     entryOfTypeC
 RDB_MSG_ENTRY_HDR_t  pkgId       = RDB_PKG_ID_END_OF_FRAME
                      headerSize  = sizeof( RDB_MSG_ENTRY_HDR_t )
                      dataSize    = 0
                      elementSize = 0


 Single Ray

 It computes the intersection of this ray and the bounding box of other objects (vehicles); it returns the position
 of these objects in sensor co-ordinates with the origin being at the sensor's mounting point.

 The multi-ray sensor provides a means to interact with the actual geometry of the 3d database from within the
 moduleManager. For this purpose, there is a communication channel between MM and the imageGenerator. This means
 that you may also take continuous features of the environment (e.g. hills, road surface) into account for the sensing.

 Real-Time Ray-Tracing (via Optix)

 The VIG-OptiX SDK is a real-time ray tracing plugin using NVIDIA's OptiX ray tracing engine.

 woody./PathToYourWorkingDir/>cp vtd.x.x.addOns.*optix*.yyyymmdd.tgz .
 woody./PathToYourWorkingDir/>tar -xzvf vtd.x.x.addOns.*optix*.yyyymmdd.tgz .

 switch your setup to OptiX.Stream or OptiX.NonVisualSpectrum

 woody./PathToYourWorkingDir/VTD.X.X>cd Data/Setups
 woody./PathToYourWorkingDir/VTD.X.X/Data/Setups/>./selectSetup

 OptiXPluginExample

 Plugin Example
 see Plugin Example

 IG plugin development
 see VTD IG plugins

 Optix4.1

 Coordinate Systems
 VIRES Installation



 Real-Time Ray-Tracing (via Optix)

 The VIG-OptiX SDK is a real-time ray tracing plugin using NVIDIA's OptiX ray tracing engine.

       woody./PathToYourWorkingDir/>cp vtd.x.x.addOns.*optix*.yyyymmdd.tgz .
   woody./PathToYourWorkingDir/>tar -xzvf vtd.x.x.addOns.*optix*.yyyymmdd.tgz .

    switch your setup to OptiX.Stream or OptiX.NonVisualSpectrum

   woody./PathToYourWorkingDir/VTD.X.X>cd Data/Setups
   woody./PathToYourWorkingDir/VTD.X.X/Data/Setups/>./selectSetup

 StartVIRES

 VTD provides a development environment for the creation of custom moduleManager plug-ins. First, make sure you have
 a license and the libraries for the moduleManager plug-in API. These are located at Develop/Modules


 \textbf{Plugin Development OptiX}
 
 OptiXPluginExample

 Plugin Example
 see Plugin Example
 IG plugin development
 see VTD IG plugins

 Optix4.1

 
 First step: compile the example
 
 The source code of the PerfectSensor is provided as an example under Develop/Modules/PerfectSensor. This example may
 be compiled with the following steps:
 
     Prerequisites:
         g++ 4.2.1
         32bit compilation
     Go to Develop/Modules/PerfectSensor
     Call qmake -spec linux-g++-32
     Call make
     The plugin will be compiled and will be stored at Develop/bin/Plugins
 
 Shared Memory
 If you are rendering large images and transfer them to shared memory, the system's shared memory limit might not be
 sufficient. You may determine the current maximum shared memory size with the command
 # cat /proc/sys/kernel/shmmax
 The setting may be changed temporarily using
 # sysctl -w kernel.shmmax=66123456
 In order to permanently set the limit, add or edit the line in /etc/sysctl.conf
 # echo "kernel.shmmax=66123456 >> /etc/sysctl.conf@
 
 
 If you tend to ignore our advice and use Unity desktop nevertheless ;-), ROD may have issues with the correct
 display of menus etc. In this case, please do the following:
 open the file ~/.config/Trolltech.conf
 add the following entry under the tag [Qt]
 [Qt]
 style=Plastique
 GNOME 3
 GUI elements (VtGui, ROD) will be screwed up. You may fix this by editing
 ~/.config/Trolltech.conf
 and adding the following lines in this file
 [Qt]
 style=Platinum
 
 Unless you have a custom configuration, the image generator will derive the display settings from the file
 Data/Setups/Current/Config/ImageGenerator/AutoCfgDisplay.xml. Here, look for the variables displayNum and screenNum
 and set them appropriately.
 Note: the image generator's config file is created by a script, so if you have auto-configuration of the IG enabled,
 you will need to change the script instead of the config file. Please perform the following steps:
 create a directory Data/Setups/Current/Scripts
 copy the file Data/Setups/Common/Scripts/configureDisplay.sh to the newly created directory
 edit the new copy and set displayNum and screenNum accordingly
 next time you load and INIT the simulation, the new settings will be written to
 Data/Setups/Current/Config/ImageGenerator/AutoCfgDisplay.xml
 displayNum is the environment variable $DISPLAY
 

 
 # 18.11.2016 by M. Dupuis
 # (c) 2016 by VIRES Simulationstechnologie GmbH
 #
 # PURPOSE:
 #   tests automatic start/stop of a simulation
 #
 #
    0 "<SimCtrl> <Stop/> <LoadScenario filename="traffic_demo.xml" /> <Init mode="operation"/> </SimCtrl>"
 #
 wait "<SimCtrl> <InitDone place="checkInitConfirmation"/> </SimCtrl>"
 #
   +1 "<SimCtrl> <Start/> </SimCtrl>"
  +5s "<Symbol name="expl01" > <Text data="End of Test" colorRGB="0xffff00" size="50.0" /> <PosScreen x="0.01" y="0
  .05" /></Symbol>"
  +1s  "<SimCtrl> <Stop/> </SimCtrl>"
 
 tcpdump 'tcp port 48190 and (((ip[2:2] - ((ip[0]&0xf)<<2)) - ((tcp[12]&0xf0)>>2)) != 0)'
 rdb image is on TCP 48190
 
 Real time rendering of high dynamic range images for validation of driver assistance systems.
 
 High dynamic range rendering in computer graphics is a well known method to create synthetic images. Some parts of
 the generated images, which can be measured in luminance are wrong – road too bright and traffic sign too dark.
 
 Digital camera and another luminance meter – luminance to pixel value.
 RGBE Image file format – HDR imaging film format.
 Light mapping through different image operations. Tone mapping resulted in more visible result.
 
 HDR technique : combining differently exposed images to produce a single HDR image.
 
 HDR images are used as input for camera systems, in order to accurately simulate the extreme lighting conditions of
 reality.
 
 Ray tracing radar prototypes have detailed material properties, multiple reflections, absorption, attenuation,
 scattering etc.
 
 VTD Vehicle Library
 All the vehicles.
 
 Scenario Editor Manual
  - Action Trigger. Actions are triggered at trigger points. Triggers can be chosen from Trigger List.
 <Traffic> <Trigger id=”myTrigger” active=”true | false” /> </Traffic>
  - SCP Gui
 How to control players ( cars ) , characters ( pedesterias ) and objects ( vegetation )
 How to control drivers
 
 VTD User Manual
 
 ROD Tutorial
 How to create a layout of roads, cities etc.
 
 VTD 2.0 - sneak preview
 Some improvements in VTD2.0. Powerpoint.
 
 VIRES Driver Characteristics
 Please see Scenario Editor Manual
 
 HDR Validation of v-IG
 The sensor simulator input data contains image, object list or ray tracing information. HDR images are used as input
 for camera systems, in order
 to accurately simulate the extreme lighting conditions of reality.
 
 TestReports
 Vehicle Dynamics - simplified
 VT-MÄK License Management

     ModuleManager
     Vehicle Configuration Files
     Material System
     Working with OpenCRG Data
     Working with Map and Terrain Data
 
 Image Generator (vIG)
 
     Sky Model
     OS Optimization
     vIG plugins
         Plugin Example
     OptiX SDK
         OptiX-related FAQs
     RDBInterface
     Post Processing
 
 0.01s, making the manager run at 100Hz.
 Sensor plug-ins are used for the extraction of data from the virtual world within a given sub-space which is usually
 connected to the own vehicle. The standard sensors work like filter which are adding some information about occlusion etc.
 

 <RDB>
     <Port name="RDBraw" number="48190" type="TCP" />
 </RDB>
 <Debug    enable="true"
           :
           performance="true" />
 <Sensor name="perfectFront" type="video">
     <Load     lib="libModulePerfectSensor.so" path="" persistent="true" />
     <Frustum  near="0.0" far="50.0" left="10.0" right="10.0" bottom="3.0" top="3.0" />
     <Cull     maxObjects="5" enable="true" />
     <Port     name="RDBout" number="48195" type="UDP" sendEgo="true" />
     <Player   default="true" />
     <Position dx="3.5" dy="0.0" dz="0.5" dhDeg="0.0" dpDeg="0.0" drDeg="0.0" />
     <Filter   objectType="pedestrian"/>
     <Filter   objectType="vehicle"/>
     <Filter   objectType="trafficSign"/>
     <Filter   objectType="obstacle"/>
     <Filter   objectType="roadInfo"/>
     <Filter   objectType="laneInfo"/>
     <Filter   objectType="roadMarks" tesselate="true"/>
 
 </Sensor>
     <Filter   objectType="trafficSign" signType="274"/>
     <Filter   objectType="trafficSign" signType="281"/>
 <Debug enable="false" />
 <Cull maxObjects="5" enable="true" maxOcclusion="0.3"/>
 <Sensor name="perfect" type="video">
     <Load     lib="libModulePerfectSensor.so" path="" persistent="true" />
     :
     <Output   sendOcclusionMatrix="true"/>
     :
 </Sensor>
 
 The occlusion matrix will be sent as an RDB package of type RDB_PKG_ID_OCCLUSION_MATRIX.
 After detecting the relevant objects (or calculating the respective information), each sensor will compose an RDB
 output data package containing the relevant information (object lists etc.). The output will be sent via the ports
 defined in the <Port> section of each sensor. Each sensor will open its own output port
 <Origin type="{USK|inertial|sensor|relative|gps|road}" dx=... dy=... dz=... dhDeg=... dpDeg=... drDeg=.../>
 RDB_IMAGE_t On the sensor's RDB output port, there will be - among others - one package of type SENSOR_OBJECT_t and
 one package of type OBJECT_STATE_t for each detected element.
 plugin: libModuleCameraSensor.so.
 
 
 <Sensor name="multiRay" type="video">

     <Load     lib="libModuleMultiRaySensor.so" path="" persistent="true" />
     <Frustum  near="0.0" far="50.0" left="10.0" right="10.0" bottom="3.0" top="3.0" />
     <Config   noRaysHorizontal="3" noRaysVertical="3" verbose="false" />
     <Port     name="RDBout" number="48195" type="TCP" sendEgo="false" />
     <Player   default="true" />
     <Position dx="3.5" dy="0.0" dz="0.5" dhDeg="0.0" dpDeg="0.0" drDeg="0.0" />
     <Debug    enable="false" />
 </Sensor>

 <TaskControl>
   :
   <Debug ...
     rayHits="true"/>
 </TaskControl>
 
 <Sensor>
   :
   <Noise axis="x" amplitude="1.0" frequency="40.0"/>
   <Noise axis="p" amplitude="0.2" frequency="20.0"/>
   :
 </Sensor>
 <Sensor>
   :
   <Noise axis="x" amplitude="1.0" frequency="40.0"/>
   <Noise axis="p" amplitude="0.2" frequency="20.0"/>
   <DataLoss duration="0.2" frequency="0.5"/>
   :
 </Sensor>
 
 
 
 
 
 
 
 
 
 Dynamics Plugins
 For test purposes you may add sinusoidal offsets to the resulting  x/y/z/h/p/r data of the vehicle dynamics before
 it is sent to the taskControl.
 Each Plug-in has one input Iface and one output Iface. The input Iface represents the whole data received by
 the moduleManager's input routines (i.e. RDB) and the output Iface represents all data generated within the plug-in
 (e.g.
 copies of the incoming data that have been found to be relevant within a sensor).
 
 
 
 
 
 As noted above, custom sensors must be derived from the class Module::SensorPlugin. At least the method
 update() must be implemented by the user. This routine is called by the ModuleManager in each
 simulation frame with the current frame number and a pointer to the interface class which contains all
 data that has been received from the TC.
 
 
 Before calling the update()-method, the routines of the base class SensorPlugin will have performed the
 following steps:
 
 - receiving of RDB data
 - object filtering (by type)
 - object detection (by frustum)
 

 
 RDB
     <RDB            name="default"
                     enable="true"
                     portType="SHM"
                     imageTransfer="false"
                     send="true"/>
 
     <RDB            name="shmIn"
                     enable="true"
                     portType="SHM"
                     imageTransfer="false"
                     receive="true"/>
 <RDB>
     <Port name="RDBraw" type="SHM" receive="true" />
     <Port name="RDBraw" type="SHM" send="true" />
 </RDB>
 

     <RDB            name="default"
                     portType="UDP"
                     imageTransfer="false"/>
     <RDB>
         <Port name="RDBraw" number="48190" type="UDP" />
     </RDB>
 
 
 The database contains the graphical elements of the virtual world. It is
 available in binary .ive-format (OpenSceneGraph). The corresponding
 logical database of the road network is stored in the OpenDRIVE format,
 an XML-based description. For the design and modification of both
 database, the editor RoadDesigner (ROD) may be purchased optionally.

  Scenario

 The scenario is stored in an XML format which is proprietary to
 VIRES. It contains references to the visual database and the logical
 database. Actions of all players are also contained in the scenario
 file. The file may be edited using the graphical ScenarioEditor.
 VTD provides an extensive set of binary data for each simulation step. The overall amount of data that is available
 on RDB is listed in
 the respective documentation. Some of the more important / frequent
 contents are given in the following list:
 
 
 Player Data (Vehicles, Pedestrians)
 
 
 position, orientation (heading, pitch, roll) and size (bounding-box)
 category of the player (vehicle, pedestrian)
 Details of Vehicles
 
 size, mass, axle distance
 information about drivetrain (speed, torque, gear...)
 information about driver-vehicle-interface (e.g. pedals, steering wheel)
 detailed information about wheels (steering angle, radius, forces etc.)
 brake pressure, spring compression (per wheel)
 status of vehicle lights
 Details of current road sections
 drive lane information (width, id, ...)
 road marks (type, color, ...)
 traffic signs and traffic lights (including current and future states)
 Data from VTD
 
 
 Images of the Image Generator
 height, width
 image data (visual range, depth information, infrared, ...)
 information about the camera which is used for generating the image (make sure you configure the TaskControl to the
 latest IG protocol version for this feature, i.e. "precision10" or higher)
 
 Sensor Data
 Perfect sensors may be positioned at arbitrary locations of
 vehicles. These may be used to simulate real sensors. Sensor output data
  is provided on dedicated connections of each sensor. The protocol also
 follows the RDB definition.
 position of the sensor
 distance to detected objects (with global object reference)
 
 Common Data
 time-of-day
 sky state
 weather conditions (fog, rain, snow)
 visibility
 road conditions (dry, wet)
 SCP provides the interface to all non-periodic communication within VTD. Among these are:
 
 Common Information About the Simulation
 filename and path of the current scenario and OpenDRIVE file
 simulation state (start, stop, ...)
 Information About Actions Within the Simulation
 execution of triggers from within the scenario
 state changes of traffic lights
 The full extent of the SCP command interface can be retrieved from the documentation in VTD/Doc/SCP_HTML/index.html.
 <Query label="a58s7" entity="player" id="1"/>"
 
 <Reply label="a58s7" entity="player" id="1" name="Ego"/>
 
 
 Database
 
 ALL SENSORS accept Crash Sensors
 
 - all
 - vehicle
 - pedestrian
 - light
 - trafficSign
 - obstacle
 - laneInfo (new in VTD 1.2.2)
 - roadMarks (new in VTD 1.2.2)
 
 
 What is a crash: Crash between bounding box of self and surrounding.
 If a crash is detected, it will issue an SCP message.

 <Filter rdbCategory="RDB_OBJECT_CATEGORY_PLAYER" rdbType="RDB_OBJECT_TYPE_PLAYER_CAR"/>
 <Filter rdbCategory="RDB_OBJECT_CATEGORY_PLAYER"/>

 The JitterSensor may be used for deteriorating the accuracy of information retrieved by the perfect sensor. On each
 component, a sinusoidal noise will be added to the actual signal. The user may specify frequency and amplitude of
 the noise per channel.
 Detection like a perfect sensor - this provides the basic object data of vehicles, pedestrians etc. Additional
 detection AND occlusion calculation for the following types of objects:traffic signs, vehicle lights (headlights,
 rear lights), street lamps, common obstacles (e.g. houses) which may occlude the former objects. The information
 about the sensor itself (contained in a package of type RDB_SENSOR_STATE_t) complements the data stream.
 
 -----

 ATZ . Automobil Technisch Zeitschrift
 VDI - Verein Deutsche Ingineure


 Class 1, Class 2 ( laser pointers ) , Class 3R, Class 3B and Class 4

 The laser power varies from 1 mw ( Laser pointers ) to  100s of watts ( Outdoor shows for example Audience scanning
 ) to MW ( Laser telescopes )


 Faster and still Reliable Sensor Fusion.

 Trying to solve this by making a generic framework and inducing 4 important details in the framework: Confusion,
 Consistency, Compromise and Confidence.

 High Dynamic Range: well known method to create synthetic images. 32 bit
 Low Dynamic Range: 8 bit
 Generated images cn be measured in Luminance, Illuminance

 High Density Rendering

 start Standard_test/Movement
 Check mark to accept the parameters
 Start the simulation.
 rdbTriggerSample is present at /VIRES/VTD.2.0/Develop/Communication/RDBTriggerSample
 shmReader -k:33130 ( default is 33130 ) is present at VTD.2.0/Develop/Communication/RDBShmSample

 The shmReader reads the shared memory over RDB.
 Client Side - VIRES side
 moduleManager.xml (
 The trigger sends the trigger over RDB via the tcp port 48190

 ---------------------------------------------------------------------
 Installation:

 VIRES Virtual Test Drive is a tool chain and modular framework for the provision of virtual environments in
 engineering simulations for the automotive and railroad industry.

 tar -xvzf vtd.2.0.3.Demo.Road.20170131.tgz -C /local/development
 tar -xvzf vtd.2.0.3.addOns.ROD64b.Standard_Dongle_20170209.tgz -C /local/development
 Run instMultiUser.sh from /local/development. It will move the binaries and other generic stuff to /opt and /var and
 make symlinks to /local/development.
 Its better to chown /local/development/bin to root.

 Demo
 VTD.2.0/bin
 VTD.2.0/Data/Distros/Current
 VTD.2.0/Data/Setups/Current
 VTD.2.0/Data/Setups/Standard
 VTD.2.0/Data/Setups/Common
 VTD.2.0/Data/Setups/Stereo
 VTD.2.0/Data/Setups/Common
 VTD.2.0/Data/Setups/Joystick
 VTD.2.0/Data/Setups/DualHost
 VTD.2.0/Data/Setups/Standard.noIG
 VTD.2.0/Data/Setups/OpenCRG
 VTD.2.0/Data/Projects/Default
 VTD.2.0/Data/Projects/Current
 VTD.2.0/Data/Projects/SampleProject
 VTD.2.0/Data/Projects/OpenCRG
 VTD.2.0/doc
 VTD.2.0/Develop/Framework
 VTD.2.0/Develop/Communication
 VTD.2.0/Runtime/Core/IG64
 VTD.2.0/Runtime/Tools/ModelConverter
 VTD.2.0/Runtime/Tools/Bugreport
 VTD.2.0/Runtime/Tools/Installation
 VTD.2.0/Runtime/Tools/VehicleController
 VTD.2.0/Runtime/Tools/Drivers
 VTD.2.0/Runtime/Tools/LicServer
 VTD.2.0/Runtime/Tools/RDBSniffer


 Plugin
 VTD.2.0/Develop/IG64/Lib
 VTD.2.0/Develop/IG64/doc
 VTD.2.0/Develop/IG64/bin
 VTD.2.0/Develop/IG64/Plugins/CarSim
 VTD.2.0/Develop/IG64/Plugins/FramebufferReader
 VTD.2.0/Develop/IG64/Plugins/OptiXPluginExample
 VTD.2.0/Develop/IG64/Plugins/PedestriansBDI_Base
 VTD.2.0/Develop/IG64/Plugins/OptiXLidar
 VTD.2.0/Develop/IG64/Plugins/EnvironmentManager
 VTD.2.0/Develop/IG64/Plugins/Symbols
 VTD.2.0/Develop/IG64/Plugins/PedestriansBDI_v13
 VTD.2.0/Develop/IG64/Plugins/SpecialEffects
 VTD.2.0/Develop/IG64/Framework
 VTD.2.0/Develop/IG64/ViresLibs/VTDFramework
 VTD.2.0/Develop/IG64/Cmake/
 VTD.2.0/Develop/IG64/3rdParty/Optix
 VTD.2.0/Develop/IG64/3rdParty/CUDA
 VTD.2.0/Develop/IG64/3rdParty/Boost
 VTD.2.0/Develop/IG64/3rdParty/OpenSceneGraph
 VTD.2.0/Develop/IG64/Tools/RDBComTester
 VTD.2.0/Develop/IG64/Tools/BuildTools

 VTD.2.0/Data/Projects/Demo.VIGPlugin
 VTD.2.0/Data/Projects/Optix.NonVisualSpectrum
 VTD.2.0/Data/Projects/Optix
 VTD.2.0/Data/Projects/Demo.OptiXPlugin
 VTD.2.0/Data/Projects/OptiXLidar
 VTD.2.0/Data/Distros/Distro/Databases/OptiX/
 VTD.2.0/Data/Setups/Demo.VIGPlugin

 ROD Package
 VTD.2.0/Runtime/Tools/RodDistro_2638_Rod64b_4.5.5

 instMultiUser.sh : This file simply creates symbolic links. The file is interactive and hence just run the file.

 selectStarup.sh : This file simply changes the setup. One can change setup from default to NoIG or something new for
 example.

 https://secure.vires.com/demo/vtd/vtd.2.0.3.Demo.Road.20170131.tgz
 https://secure.vires.com/demo/vtd/vtd.2.0.3.addOns.ROD64b.Standard_Dongle_20170209.tgz

 login: demo
 OpenSesame: viresDemo


 The dongle can be configured using export VI_LIC_DEVICE="name_of_the_dongle" in vtdStart.sh
 VTD Starts in config mode - RED is Task Control and GREEN is ParameterServer. This is called Config mode.

 License

 The license file needs to be placed under VTD2.0/bin/
 Please make sure the license file obtained has the same MAC Address as the Dongle.

 License Hardware Configuration
 Wireless Dongle
 /etc/modules.load/modules.conf - write mt7601u to load this module at run time.
 To check simply modprobe mt7601u

 14.04
 The precondition is that the wifi dongle should be loaded in ifconfig.
 sudo apt-add-repository ppa:thopiekar/mt7601
 sudo apt-get update
 sudo apt-get install mt7601-sta-dkms

 Sempre Wireless Dongles use MediaTek drivers ( mt7601u ). The following will load the driver mt7601Usta to be found
 under
 /lib/modules/3.13.0-65-generic/updates/dkms/mt7601Usta.ko
 Please check using modinfo mt7601Usta

 16.04 - automatic because the drivers is already built in the kernel
 To check please invoke lsmod | grep mt7601u

 if the device is not present in ifconfig, then check for ifconfig -a
 Then start the link ip link set dev  up

 Open the file Data/Setups/Current/Config/SimServer/simServer.xml
 Add an environment variable: <EnvVar name="VI_LIC_DEVICE" val="ed8sf0" /> (replace ed8sf0 with the name of your device)
 Find the name of the device by using ifconfig.

 In order for VTD to work correctly in terms of network communication, please make sure that your system has a valid
 hostname and a valid host address. If you are not connected to any network, please set a static address for your
 system. You may also just edit the file /etc/hosts and add the entry
 127.0.0.2 nameOfYourHost


 Warping 

 This is the configuration you will need to define in some IG config (IGbase.xml or ProjectIGConfig.xml):

  <SystemConfig>  
    <FilePath path="IGLinks/Project/ImageGenerator/Misc" />
  </SystemConfig>  

...

    <PostProcessing name="MyPostProcessing"  />

    <PostProcessingPipelineConfigurator name="MyPostProcessingPipelineConfigurator">
      <Pipeline hideSceneFromDefaultView="1" >
    <Step type="PPSTextureRect" name="OriginalScene">
      <Inputs renderLights="1">
        <NodeInput  inputNo="0" type="scene"  />
      </Inputs>                
      <RTT  sizeMode="viewport"  bufferFormat="GL_RGB8" />

      <SAQ lowerLeftX="0" lowerLeftY="0" width="0.5" height="1" isForDebug="1" enableSRGB="0" />
    </Step>

    <Step type="PPSWarpingMesh" name="Warping" >
      <Inputs sourceStep="OriginalScene" blendImageAlpha="exampleAlphamap.rgb" />
      <RTT  sizeMode="viewport"  bufferFormat="GL_RGB8" />
      <Mesh width="20" height="30" file="exampleDistortion.txt" />
      <SAQ lowerLeftX="0.0" lowerLeftY="0" width="1" height="1" isForDebug="0" enableSRGB="0" />
    </Step>

      </Pipeline>            
    </PostProcessingPipelineConfigurator>




*/
